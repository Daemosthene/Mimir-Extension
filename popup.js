function buildRequestBody(toolName, text) {
  const base = { action: toolName, text };

  switch (toolName) {
    case "Summarize":
      return { ...base, mode: "concise", includeKeywords: true };
    case "Explain Like I'm 5":
      return { ...base, simplifyLevel: 5 };
    case "Citation Finder":
      return { ...base, includeLinks: true, format: "APA" };
    case "Definition":
      return { ...base, includeExamples: true, simplify: true };
    case "Daily Brief":
      return { ...base, context: "yesterday", includeTasks: true };
    case "Socratic Review":
      return { ...base, questionStyle: "dialectic", depth: "high" };
    case "Flashcard Generator":
      return { ...base, format: "anki", maxCards: 10 };
    case "Turn Professional":
      return { ...base, tone: "professional", polish: true };
    case "Translate Text":
      return { ...base, targetLanguage: "en", preserveFormat: true };
    case "AI Detector":
      return { ...base, detectAI: true };
    default:
      return base;
  }
}

// Helper function to detect if text is a multiple choice question
function isMultipleChoiceQuestion(text) {
  // Quick check for common MCQ indicators to avoid expensive regex
  if (!text.includes('A.') && !text.includes('1.') && !text.includes('option') &&
      !text.toLowerCase().includes('true') && !text.toLowerCase().includes('false')) {
    return false;
  }
  
  // Look for patterns like "A.", "B.", "C.", etc.
  const mcqPattern = /(?:\n|\r|\r\n|^)\s*[A-D][\.\)].*(?:\n|\r|\r\n)\s*[A-D][\.\)].*(?:\n|\r|\r\n)\s*[A-D][\.\)].*/i;
  // Also check for numerical options like "1.", "2.", "3.", etc.
  const numericalPattern = /(?:\n|\r|\r\n|^)\s*[1-4][\.\)].*(?:\n|\r|\r\n)\s*[1-4][\.\)].*(?:\n|\r|\r\n)\s*[1-4][\.\)].*/i;
  // Check for true/false questions
  const trueFalsePattern = /(?:\n|\r|\r\n|^)(?:.*)(?:true\s+or\s+false|true\/false)(?:.*?)(?:\?|\.)/i;
  
  return mcqPattern.test(text) || numericalPattern.test(text) || trueFalsePattern.test(text);
}

const tools = [
  { name: "Summarize", description: "Get a context-aware summary of the selected text." },
  { name: "Explain Like I'm 5", description: "Simplify the selected text so a 5-year-old could understand it." },
  { name: "Translate Text", description: "Translate selected or full-page text from any language into English." },
  { name: "Definition", description: "Define a selected word or phrase and optionally simplify it." },
  { name: "Turn Professional", description: "Polish informal writing into professional, work-ready prose." },
  { name: "Socratic Review", description: "Ask critical questions to clarify and challenge your thinking." },
  { name: "Daily Brief", description: "Summarize yesterday's notes, list tasks, and suggest what to work on." },
  { name: "Citation Finder", description: "Suggest sources or references related to the selected content." },
  { name: "Flashcard Generator", description: "Turn notes or articles into tab-separated, Anki-compatible flashcards." },
  { name: "Upload Image", description: "Upload an image to extract text and find answers." },
  { name: "AI Detector", description: "Detect if text was generated by AI or written by humans." }
];

// 1) Define the palette
const themeColors = {
  default: "#4287f5",
  red:     "#A4262C",
  orange:  "#CA5010",
  darkblue:"#40587C",
  green:   "#407855",
  purple:  "#8764B8",
  teal:    "#038387",
  yellow:  "#CEA230",
  white:   "#ffffff",
  black:   "#000000"
};

// 2) Helper to apply a theme key to your CSS variable
function applyThemeColor(themeKey) {
  const color = themeColors[themeKey] || themeColors.default;
  document.documentElement.style.setProperty("--accent-color", color);
  
  // Special handling for white and black themes
  if (color === "#ffffff") {
    document.documentElement.style.setProperty("--text-color", "#ffffff");
    
    // Keep non-button text WHITE for white theme
    const textElements = document.querySelectorAll('body, h2, .label, .settings-title, #tagline, #openSettings, .back-button');
    textElements.forEach(element => {
      element.style.color = '#ffffff';
    });
    
    // Change ONLY button text to BLACK for white theme
    const buttonElements = document.querySelectorAll('.action-button, #enterPromptBtn, #editTextBtn, #bubbleModeBtn, #generatePromptBtn, #cancelPromptBtn');
    buttonElements.forEach(element => {
      element.style.color = '#000000';
      element.style.border = 'none'; // Remove border for white theme
    });
    
    // Handle button spans for animated buttons - make them BLACK
    const buttonSpans = document.querySelectorAll('.action-button .span-mother span, .action-button .span-mother2 span');
    buttonSpans.forEach(span => {
      span.style.color = '#000000';
    });
  } else if (color === "#000000") {
    document.documentElement.style.setProperty("--text-color", "#ffffff");
    
    // Keep non-button text WHITE for black theme
    const textElements = document.querySelectorAll('body, h2, .label, .settings-title, #tagline, #openSettings, .back-button');
    textElements.forEach(element => {
      element.style.color = '#ffffff';
    });
    
    // Reset button text to white for black theme and add white borders
    const buttonElements = document.querySelectorAll('.action-button, #enterPromptBtn, #editTextBtn, #bubbleModeBtn, #generatePromptBtn, #cancelPromptBtn');
    buttonElements.forEach(element => {
      element.style.color = '#ffffff';
      element.style.border = '1px solid #ffffff'; // Add white border for black theme
    });
    
    // Reset button spans for animated buttons
    const buttonSpans = document.querySelectorAll('.action-button .span-mother span, .action-button .span-mother2 span');
    buttonSpans.forEach(span => {
      span.style.color = '#ffffff';
    });
  } else {
    document.documentElement.style.setProperty("--text-color", color);
    // Reset text color to accent color for other themes
    const textElements = document.querySelectorAll('body, h2, .label, .settings-title, #tagline, #openSettings, .back-button');
    textElements.forEach(element => {
      element.style.color = color;
    });
    
    // Reset button text to white for other themes and remove borders
    const buttonElements = document.querySelectorAll('.action-button, #enterPromptBtn, #editTextBtn, #bubbleModeBtn, #generatePromptBtn, #cancelPromptBtn');
    buttonElements.forEach(element => {
      element.style.color = '#ffffff';
      element.style.border = 'none'; // Remove border for other themes
    });
    
    // Reset button spans for animated buttons
    const buttonSpans = document.querySelectorAll('.action-button .span-mother span, .action-button .span-mother2 span');
    buttonSpans.forEach(span => {
      span.style.color = '#ffffff';
    });
  }
}

// 3) Listen for live changes to `theme` in storage
chrome.storage.onChanged.addListener((changes, area) => {
  if (area === "local" && changes.theme) {
    applyThemeColor(changes.theme.newValue);
  }
});

// (Optionally) also catch the custom `themeChanged` message
chrome.runtime.onMessage.addListener((msg) => {
  if (msg.type === "themeChanged" && msg.theme) {
    applyThemeColor(msg.theme);
  }
});


const toolsView = document.getElementById("toolsView");
const buttonsDiv = document.getElementById("buttons");
const lastAttempts = {};

tools.forEach(tool => {
  const toolDiv = document.createElement("div");
  toolDiv.className = "tool";

  const headerDiv = document.createElement("div");
  headerDiv.className = "tool-header";

  const actionBtn = document.createElement("button");
  actionBtn.className = "action-button";
  actionBtn.textContent = tool.name;
  actionBtn.dataset.action = tool.name;

  const descDiv = document.createElement("div");
  descDiv.className = "description";
  descDiv.textContent = tool.description;

  const spinner = document.createElement("div");
  spinner.className = "mimir-spinner";
  spinner.style.display = "none";
  
  // Add loading wave HTML to spinner with explicit styles
  spinner.innerHTML = `
    <div class="loading-wave" style="display: flex; align-items: flex-end; justify-content: center;">
      <div class="loading-bar" style="display: block; background-color: var(--accent-color);"></div>
      <div class="loading-bar" style="display: block; background-color: var(--accent-color);"></div>
      <div class="loading-bar" style="display: block; background-color: var(--accent-color);"></div>
      <div class="loading-bar" style="display: block; background-color: var(--accent-color);"></div>
    </div>
  `;
  
  headerDiv.appendChild(spinner);

  // Handle different tool types
  if (tool.name === "Upload Image") {
    actionBtn.addEventListener("click", async () => {
      const { allowed } = await checkToolAccess("Upload Image");
      if (!allowed) {
        showUpgradeModal("🔒 This tool is limited to one use per day for free users. Upgrade to Pro for unlimited access.");
        return;
      }
      // Create a hidden file input element
      const fileInput = document.createElement("input");
      fileInput.type = "file";
      fileInput.accept = "image/*";
      fileInput.style.display = "none";

      fileInput.onchange = async () => {
        if (!fileInput.files || fileInput.files.length === 0) {
          return;
        }
        const file = fileInput.files[0];
        spinner.style.display = "block";
        headerDiv.classList.add("loading");
        document.getElementById("result").innerText = "Uploading and processing image...";

        try {
          // Convert file to base64 to send through chrome.runtime.sendMessage
          const reader = new FileReader();
          reader.onload = function(e) {
            const base64Data = e.target.result;
            
            chrome.runtime.sendMessage({
              type: "proxy_api_request",
              payload: {
                url: "https://mimir-server-daemosthene-mimir-extension.vercel.app/api/mimir",
                method: "POST",
                body: {
                  action: "Upload Image",
                  imageData: base64Data
                }
              }
            }, (response) => {
              if (chrome.runtime.lastError) {
                showResultPopup('Error: ' + chrome.runtime.lastError.message, "Upload Image Error");
                return;
              }
              
              if (response && response.success) {
                const dataOut = response.data;
                let outputText = '';
                if (dataOut.answers) {
                  outputText += 'ANSWERS:\n' + dataOut.answers + '\n\n';
                }
                if (dataOut.ocrText) {
                  outputText += 'EXTRACTED TEXT:\n' + dataOut.ocrText;
                }
                if (!outputText) {
                  outputText = 'No response from server.';
                }
                showResultPopup(outputText, "Upload Image Result");
              } else {
                showResultPopup('Error: ' + (response ? response.error : 'No response'), "Upload Image Error");
              }
            });
          };
          reader.readAsDataURL(file);
          
        } catch (error) {
          showResultPopup('Error: ' + error.message, "Upload Image Error");
        } finally {
          spinner.style.display = "none";
          headerDiv.classList.remove("loading");
        }
      };

      // Trigger the file input dialog
      document.body.appendChild(fileInput);
      fileInput.click();
      // Remove the input after use
      fileInput.remove();
    });
  } else {
    // Handle text-based tools
    actionBtn.addEventListener("click", async () => {
      const { allowed } = await checkToolAccess(tool.name);
      if (!allowed) {
        showUpgradeModal("🔒 This tool is limited to one use per day for free users. Upgrade to Pro for unlimited access.");
        return;
      }
      // Make sure spinner is visible first thing
      spinner.style.display = "block";
      // Force a reflow to ensure the spinner shows up
      void spinner.offsetWidth;
      headerDiv.classList.add("loading");
      
      chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
        chrome.scripting.executeScript(
          {
            target: { tabId: tabs[0].id },
            func: () => window.getSelection().toString()
          },
          async (results) => {
            let selected = results[0]?.result?.trim();
            const name = tool.name;
            const allowFullPageFallback = !["Definition"].includes(name);

            if (!selected) {
              if (allowFullPageFallback) {
                if (lastAttempts[name]) {
                  chrome.scripting.executeScript(
                    {
                      target: { tabId: tabs[0].id },
                      func: () => document.body.innerText
                    },
                    async (pageResults) => {
                      const pageText = pageResults[0]?.result?.trim();
                      
                      try {
                        const res = await fetch("https://mimir-server-daemosthene-mimir-extension.vercel.app/api/mimir", {
                          method: "POST",
                          headers: { "Content-Type": "application/json" },
                          body: JSON.stringify(buildRequestBody(name, pageText))
                        });

                        const contentType = res.headers.get('content-type');
                        if (!contentType || !contentType.includes('application/json')) {
                          const htmlResponse = await res.text();
                          console.error("Non-JSON response received:", htmlResponse.substring(0, 200));
                          throw new Error("Server returned HTML instead of JSON. Please try again.");
                        }

                        const dataOut = await res.json();
                        showResultPopup(dataOut.result || dataOut.error || "No response.", `${name} Result`);
                      } catch (error) {
                        console.error("API request error:", error);
                        showResultPopup("Error: " + error.message, `${name} Error`);
                      } finally {
                        spinner.style.display = "none";
                        headerDiv.classList.remove("loading");
                      }
                    }
                  );
                } else {
                  lastAttempts[name] = true;
                  showResultPopup(`Please select some text first or press again to ${name.toLowerCase()} the entire page.`, `${name} - No Text Selected`);
                  spinner.style.display = "none";
                  headerDiv.classList.remove("loading");
                }
              } else {
                showResultPopup("Please select some text first.", `${name} - No Text Selected`);
                spinner.style.display = "none";
                headerDiv.classList.remove("loading");
              }
              return;
            }

            lastAttempts[name] = false;
            
            try {
              const res = await fetch("https://mimir-server-daemosthene-mimir-extension.vercel.app/api/mimir", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(buildRequestBody(name, selected))
              });

              const contentType = res.headers.get('content-type');
              if (!contentType || !contentType.includes('application/json')) {
                const htmlResponse = await res.text();
                console.error("Non-JSON response received:", htmlResponse.substring(0, 200));
                throw new Error("Server returned HTML instead of JSON. Please check if the server is running properly.");
              }

              const dataOut = await res.json();
              showResultPopup(dataOut.result || dataOut.error || "No response.", `${name} Result`);
            } catch (error) {
              console.error("API request error:", error);
              let errorMessage = "Error: " + error.message;
              
              if (error.message.includes("Failed to fetch")) {
                errorMessage = "Network error: Cannot connect to server. Please check your internet connection.";
              } else if (error.message.includes("HTML instead of JSON")) {
                errorMessage = "Server error: The API server may be down or misconfigured.";
              }
              
              showResultPopup(errorMessage, `${name} Error`);
            } finally {
              // Hide spinner and remove 'loading' class when finished
              spinner.style.display = "none";
              headerDiv.classList.remove("loading");
            }
          }
        );
      });
    });
  }

  headerDiv.appendChild(actionBtn);
  toolDiv.appendChild(headerDiv);
  toolDiv.appendChild(descDiv);
  buttonsDiv.appendChild(toolDiv);
});

// Slide to settings and back
function slideToSettings() {
  toolsView.classList.remove("active");
  toolsView.classList.add("slide-in-right");
  const settingsView = document.getElementById("settingsView");
  settingsView.classList.add("active", "slide-in-left");
}

function slideToTools() {
  const settingsView = document.getElementById("settingsView");
  settingsView.classList.remove("active");
  settingsView.classList.add("slide-in-right");
  toolsView.classList.remove("slide-in-right");
  toolsView.classList.add("active");
}

window.addEventListener("DOMContentLoaded", () => {
  chrome.storage.local.get("theme", ({ theme }) => {
    applyThemeColor(theme || "default");
  });

  // Check for admin mode on startup
  chrome.storage.local.get("isAdminMode", ({ isAdminMode }) => {
    if (!isAdminMode) {
      // Try to detect admin mode by making a test request to the server
      detectAdminMode();
    }
  });

  // Add result popup close functionality - MOVED TO TOP OF DOMContentLoaded
  const resultCloseBtn = document.getElementById("resultCloseBtn");
  const resultPopup = document.getElementById("resultPopup");
  
  if (resultCloseBtn) {
    resultCloseBtn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      hideResultPopup();
    });
  }
  
  // Close popup when clicking outside the content
  if (resultPopup) {
    resultPopup.addEventListener("click", (e) => {
      if (e.target === resultPopup) {
        hideResultPopup();
      }
    });
    
    // Close popup on Escape key
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && resultPopup.style.display === "flex") {
        hideResultPopup();
      }
    });
  }

  // Apply text effect to all buttons
  applyTextEffectToAllButtons();
  
  // Apply text effect to dynamically created buttons
  const observer = new MutationObserver((mutations) => {
    mutations.forEach(mutation => {
      if (mutation.addedNodes.length) {
        mutation.addedNodes.forEach(node => {
          // Check if the added node is a button
          if (node.nodeType === 1 && node.tagName === 'BUTTON') {
            applyTextEffectToButton(node);
          }
          
          // Check if the added node contains buttons
          if (node.nodeType === 1) {
            const buttons = node.querySelectorAll('button');
            buttons.forEach(button => {
              applyTextEffectToButton(button);
            });
          }
        });
      }
    });
  });
  
  // Start observing the document for added buttons
  observer.observe(document.body, { childList: true, subtree: true });

  // Initialize theme selector in settings view
  const themeSelector = document.getElementById("themeSelector");
  if (themeSelector) {
    chrome.storage.local.get("theme", ({ theme }) => {
      // Set the current theme in the dropdown
      if (theme) {
        themeSelector.value = theme;
      }
      
      // Add event listener for theme changes
      themeSelector.addEventListener("change", () => {
        const newTheme = themeSelector.value;
        chrome.storage.local.set({ theme: newTheme }, () => {
          // Apply the theme immediately
          applyThemeColor(newTheme);
          
          // Send messages to update icon and other components
          chrome.runtime.sendMessage({ type: "themeChanged", theme: newTheme });
          chrome.runtime.sendMessage({ type: "setIconByTheme", theme: newTheme });
        });
      });
    });
  }

  // Attach Settings
  const openSettings = document.getElementById("openSettings");
  if (openSettings) {
    openSettings.addEventListener("click", () => {
      slideToSettings();
    });
  }
  
  // Attach back button in settings
  const backToTools = document.getElementById("backToTools");
  if (backToTools) {
    backToTools.addEventListener("click", () => {
      slideToTools();
    });
  }

  // Attach Blink search functionality
  const blinkSearch = document.getElementById("blinkSearch");
  const blinkIcon = document.getElementById("blinkIcon");
  const blinkSpinner = document.getElementById("blinkSpinner");
  const resultDiv = document.getElementById("result");

  if (blinkSearch && blinkIcon) {
    // Execute search when clicking the icon
    blinkIcon.addEventListener("click", () => {
      handleBlinkSearch();
    });

    // Execute search on Enter key press
    blinkSearch.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        handleBlinkSearch();
      }
    });
  }

  // Attach Enter Prompt
  const enterPromptBtn = document.getElementById("enterPromptBtn");
  const editTextBtn = document.getElementById("editTextBtn");
  const promptSection = document.getElementById("promptSection");
  const generatePromptBtn = document.getElementById("generatePromptBtn");
  const cancelPromptBtn = document.getElementById("cancelPromptBtn");
  const promptInput = document.getElementById("promptInput");
  const editResponseBtn = document.getElementById("editResponseBtn");
  const buttonsDivPrompt = document.getElementById("buttons"); 
  const topButtonsContainer = document.getElementById("topButtonsContainer");
  const blinkSearchContainer = document.getElementById("blinkSearchContainer");
  let lastGeneratedResponse = "";

  // Initially hide the edit response button
  if (editResponseBtn) {
    editResponseBtn.style.display = "none";
  }

  // Add event listener for the Edit Text button
  if (editTextBtn) {
    editTextBtn.addEventListener("click", () => {
      chrome.tabs.create({ url: chrome.runtime.getURL("prompt-editor.html") });
    });
  }

  // Add event listener for the Bubble Mode button
  const bubbleModeBtn = document.getElementById("bubbleModeBtn");
  if (bubbleModeBtn) {
    bubbleModeBtn.addEventListener("click", () => {
      showBubbleMode();
    });
  }

  if (enterPromptBtn) {
    enterPromptBtn.addEventListener("click", () => {
      // Get any selected text from the active tab
      chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
        chrome.scripting.executeScript(
          {
            target: { tabId: tabs[0].id },
            func: () => window.getSelection().toString()
          },
          (results) => {
            const selectedText = results[0]?.result?.trim() || "";
            
            // Show prompt section and hide other elements
            promptSection.style.display = "block";
            buttonsDivPrompt.style.display = "none";
            resultDiv.innerText = "";
            editResponseBtn.style.display = "none";
            
            // Pre-fill the prompt input with selected text
            if (selectedText) {
              promptInput.value = selectedText;
            }

            // Hide blink search and top buttons when prompt section is visible
            if (topButtonsContainer) topButtonsContainer.style.display = "none";
            if (blinkSearchContainer) blinkSearchContainer.style.display = "none";
          }
        );
      });
    });
  }

  if (cancelPromptBtn) {
    cancelPromptBtn.addEventListener("click", () => {
      // Hide prompt section and show other elements
      promptSection.style.display = "none";
      buttonsDivPrompt.style.display = "block";
      promptInput.value = "";
      
      // Show Edit Text button again if it was hidden
      if (editTextBtn) {
        editTextBtn.style.display = "block";
      }

      // Show blink search and top buttons when prompt section is hidden
      if (topButtonsContainer) topButtonsContainer.style.display = "flex";
      if (blinkSearchContainer) blinkSearchContainer.style.display = "block";
    });
  }

  if (generatePromptBtn) {
    generatePromptBtn.addEventListener("click", async () => {
      const promptText = promptInput.value.trim();
      
      if (!promptText) {
        showResultPopup("Please enter a prompt before generating a response.", "Enter Prompt - No Text");
        return;
      }
      
      generatePromptBtn.disabled = true;
      generatePromptBtn.textContent = "Generating...";
      
      try {
        const isMCQ = isMultipleChoiceQuestion(promptText);
        
        const res = await fetch("https://mimir-server-daemosthene-mimir-extension.vercel.app/api/mimir", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            action: isMCQ ? "Answer MCQ" : "Essay Response",
            text: promptText,
            detailed: true
          })
        });
        
        // Validate response content type
        const contentType = res.headers.get('content-type');
        if (!contentType || !contentType.includes('application/json')) {
          const htmlResponse = await res.text();
          console.error("Non-JSON response received:", htmlResponse.substring(0, 200));
          throw new Error("Server returned HTML instead of JSON. The API server may be experiencing issues.");
        }
        
        if (!res.ok) {
          const errorData = await res.json().catch(() => ({ error: `HTTP ${res.status}` }));
          throw new Error(errorData.error || `API error: ${res.status}`);
        }
        
        const dataOut = await res.json();
        const response = dataOut.result || dataOut.error || "No response received from the server.";
        
        lastGeneratedResponse = response;
        showResultPopup(response, "Enter Prompt Result");
        promptSection.style.display = "none";
        buttonsDivPrompt.style.display = "block";
        
        if (editResponseBtn) {
          editResponseBtn.style.display = "block";
        }
        
        if (topButtonsContainer) topButtonsContainer.style.display = "flex";
        if (blinkSearchContainer) blinkSearchContainer.style.display = "block";
        if (editTextBtn) {
          editTextBtn.style.display = "block";
        }
        
      } catch (error) {
        console.error("Generate prompt error:", error);
        let errorMessage = `Error: ${error.message}`;
        
        if (error.message.includes("Failed to fetch")) {
          errorMessage = "Network error: Cannot connect to server. Please check your internet connection and try again.";
        } else if (error.message.includes("HTML instead of JSON")) {
          errorMessage = "Server error: The API server is not responding correctly. Please try again later.";
        }
        
        showResultPopup(errorMessage + "\n\nPlease try again.", "Enter Prompt Error");
      } finally {
        generatePromptBtn.disabled = false;
        generatePromptBtn.textContent = "Generate Response";
      }
    });
  }

  // Modify editResponseBtn click handler to open prompt-editor.html and pass lastGeneratedResponse
  if (editResponseBtn) {
    editResponseBtn.addEventListener("click", () => {
      // Store lastGeneratedResponse in chrome.storage.local for prompt-editor to load into editor
      chrome.storage.local.set({ promptEditorEditText: lastGeneratedResponse || "" }, () => {
        chrome.tabs.create({ url: chrome.runtime.getURL("prompt-editor.html") });
      });
    });
  }

  // Add Enter key support for promptInput to trigger generatePromptBtn click
  if (promptInput) {
    promptInput.addEventListener("keydown", (e) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        generatePromptBtn.click();
      }
    });
  }

  // Inject RobotoCondensed-MediumItalic font-face for modal if not already present
  if (!document.getElementById("mimir-upgrade-modal-font")) {
    const fontStyle = document.createElement("style");
    fontStyle.id = "mimir-upgrade-modal-font";
    fontStyle.textContent = `
      @font-face {
        font-family: 'RobotoCondensedMediumItalic';
        src: url('RobotoCondensed-MediumItalic.ttf') format('truetype');
        font-style: italic;
        font-weight: normal;
      }
      #mimir-upgrade-modal, #mimir-upgrade-modal * {
        font-family: 'RobotoCondensedMediumItalic', Arial, sans-serif !important;
      }
      #mimir-upgrade-modal .mimir-upgrade-modal-content {
        font-style: normal !important;
      }
      #mimir-upgrade-modal-close {
        transition: none !important;
        background: none !important;
        color: #aaa !important;
        border: none !important;
        font-size: 13px !important;
        cursor: pointer !important;
        font-style: normal !important;
        padding: 0 !important;
        margin: 0 !important;
        box-shadow: none !important;
        outline: none !important;
        line-height: 1.2 !important;
        vertical-align: middle !important;
        position: static !important;
        min-width: 0 !important;
        min-height: 0 !important;
        height: auto !important;
      }
      #mimir-upgrade-modal-close:hover {
        color: #aaa !important;
        background: none !important;
        transform: none !important;
        box-shadow: none !important;
        outline: none !important;
        position: static !important;
        top: auto !important;
        left: auto !important;
      }
    `;
    document.head.appendChild(fontStyle);
  }

  // Modal for upgrade prompt
  if (!document.getElementById("mimir-upgrade-modal")) {
    const modal = document.createElement("div");
    modal.id = "mimir-upgrade-modal";
    modal.style.cssText = `
      display: none; position: fixed; z-index: 9999; left: 0; top: 0; width: 100vw; height: 100vh;
      background: rgba(0,0,0,0.45); justify-content: center; align-items: center;
    `;
    modal.innerHTML = `
      <div class="mimir-upgrade-modal-content" style="
        background: #232323; color: #fff; border-radius: 10px; padding: 28px 24px 20px 24px; min-width: 260px; max-width: 340px; box-shadow: 0 8px 32px #0008; text-align: center; position: relative; font-style: normal;">
        <div style="font-size: 20px; font-weight: bold; margin-bottom: 10px; font-style: normal;">Upgrade to Mimir Pro</div>
        <div id="mimir-upgrade-modal-msg" style="font-size: 15px; margin-bottom: 18px; font-style: normal;"></div>
        <a id="mimir-upgrade-modal-btn" href="https://mimir-server-daemosthene-vercel.app/api/create-checkout" target="_blank"
          style="display: inline-block; background: var(--accent-color,#4287f5); color: #fff; font-weight: bold; padding: 8px 18px; border-radius: 5px; text-decoration: none; font-size: 15px; margin-bottom: 10px; font-style: normal;">
          Go Pro
        </a>
        <br>
      </div>
    `;
    document.body.appendChild(modal);

    // Remove the close button and add overlay click-to-close
    modal.addEventListener("click", (e) => {
      if (e.target === modal) {
        modal.style.display = "none";
      }
    });
  }
});

// Helper to show the upgrade modal with a custom message
function showUpgradeModal(msg) {
  const modal = document.getElementById("mimir-upgrade-modal");
  if (modal) {
    document.getElementById("mimir-upgrade-modal-msg").innerText = msg || "This feature is limited to Pro users.";
    modal.style.display = "flex";
  }
}

// Tools that are gated for free users (1 use/day)
const gatedTools = [
  "Turn Professional", "Socratic Review", "Daily Brief", "Citation Finder",
  "Flashcard Generator", "Upload Image", "Enter Prompt", "Blink", "AI Detector"
];

// Helper to check if user is Pro and if tool is gated
function checkToolAccess(toolName) {
  return new Promise((resolve) => {
    chrome.storage.local.get(["isProUser", "usage", "isAdminMode"], ({ isProUser, usage, isAdminMode }) => {
      // Check for admin mode first - bypass all restrictions
      if (isAdminMode) {
        console.log("🔥 CLIENT ADMIN MODE: Bypassing usage restrictions for", toolName);
        return resolve({ allowed: true });
      }
      
      if (isProUser) return resolve({ allowed: true });
      const today = new Date().toISOString().split('T')[0];
      usage = usage || {};
      const dayUsage = usage[today] || {};
      // Only 1 use per day for gated tools
      if (gatedTools.includes(toolName)) {
        const count = dayUsage[toolName] || 0;
        if (count < 1) {
          // Increment usage
          dayUsage[toolName] = count + 1;
          usage[today] = dayUsage;
          chrome.storage.local.set({ usage }, () => resolve({ allowed: true }));
        } else {
          resolve({ allowed: false });
        }
      } else {
        resolve({ allowed: true });
      }
    });
  });
}

// --- Stripe Pro Upgrade Integration ---
// Listen for Go Pro button click to start checkout and store sessionId
document.body.addEventListener("click", async (e) => {
  const btn = e.target.closest("#mimir-upgrade-modal-btn");
  if (btn) {
    e.preventDefault();
    // Start checkout session via backend
    try {
      const res = await fetch("https://mimir-server-daemosthene-mimir-extension.vercel.app/api/create-checkout", {
        method: "POST"
      });
      const data = await res.json();
      if (data.url && data.sessionId) {
        // Store sessionId for later verification
        chrome.storage.local.set({ checkoutSessionId: data.sessionId });
        window.open(data.url, "_blank");
      } else if (data.url) {
        window.open(data.url, "_blank");
      }
    } catch (err) {
      alert("Failed to start checkout: " + err.message);
    }
  }
});

// On popup load, check if we have a checkoutSessionId and verify Pro status
chrome.storage.local.get("checkoutSessionId", ({ checkoutSessionId }) => {
  if (checkoutSessionId) {
    verifyProStatus(checkoutSessionId);
  }
});

// Helper to verify Pro status and update storage
async function verifyProStatus(sessionId) {
  try {
    const res = await fetch(
      `https://mimir-server-daemosthene-mimir-extension.vercel.app/api/verify-subscription?sessionId=${sessionId}`
    );
    const { status } = await res.json();
    const isActive = status === "active";
    chrome.storage.local.set({ isProUser: isActive });
  } catch (err) {
    // Optionally handle error
  }
}

// Function to handle Blink search
async function handleBlinkSearch() {
  const blinkSearch = document.getElementById("blinkSearch");
  const blinkSpinner = document.getElementById("blinkSpinner");
  const inputContainer = document.querySelector(".input-container");

  const query = blinkSearch.value.trim();
  if (!query) {
    showResultPopup("Please enter a question.", "Blink - No Question");
    return;
  }

  const { allowed } = await checkToolAccess("Blink");
  if (!allowed) {
    showUpgradeModal("🔒 Blink is limited to one use per day for free users. Upgrade to Pro for unlimited access.");
    return;
  }

  blinkSpinner.style.display = "block";
  inputContainer.classList.add("with-spinner");

  try {
    console.log("🔥 Sending Blink request:", query);
    
    const requestBody = {
      action: "Blink",
      text: query,
      maxWords: 25,
      concise: true
    };
    
    console.log("🔥 Request body:", JSON.stringify(requestBody, null, 2));

    const response = await fetch("https://mimir-server-daemosthene-mimir-extension.vercel.app/api/mimir", {
      method: "POST",
      headers: { 
        "Content-Type": "application/json"
      },
      body: JSON.stringify(requestBody)
    });

    console.log("🔥 Response status:", response.status);
    console.log("🔥 Response headers:", response.headers.get('content-type'));

    const contentType = response.headers.get('content-type');
    if (!contentType || !contentType.includes('application/json')) {
      const htmlResponse = await response.text();
      console.error("🔥 Blink non-JSON response:", htmlResponse.substring(0, 500));
      throw new Error("Server returned HTML instead of JSON. Please check if the server is running.");
    }

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ error: `HTTP ${response.status}` }));
      console.error("🔥 Blink API error:", errorData);
      throw new Error(errorData.error || `API request failed with status ${response.status}`);
    }

    const data = await response.json();
    console.log("🔥 Blink response data:", data);
    
    if (data.result) {
      showResultPopup(data.result, "Blink Result");
    } else if (data.error) {
      console.error("🔥 Server returned error:", data.error);
      showResultPopup(`Error: ${data.error}`, "Blink Error");
    } else {
      console.error("🔥 No result or error in response:", data);
      showResultPopup("No answer found. The server response was empty.", "Blink Result");
    }
  } catch (error) {
    console.error("🔥 Blink search error:", error);
    console.error("🔥 Error stack:", error.stack);
    
    let errorMessage = "Error: Could not get an answer.";
    
    if (error.message.includes("Failed to fetch")) {
      errorMessage = "Network error: Cannot connect to server. Please check your connection and try again.";
    } else if (error.message.includes("HTML instead of JSON")) {
      errorMessage = "Server error: API server is returning HTML instead of JSON. Please check server configuration.";
    } else if (error.message.includes("HTTP 500")) {
      errorMessage = "Server error: Internal server error occurred. Please try again in a moment.";
    } else if (error.message.includes("HTTP 400")) {
      errorMessage = "Request error: The question format may be invalid. Please try rephrasing your question.";
    } else {
      errorMessage = `Error: ${error.message || 'Unknown error occurred'}`;
    }
    
    showResultPopup(errorMessage + "\n\n");
  } finally {
    blinkSpinner.style.display = "none";
    inputContainer.classList.remove("with-spinner");
  }
}

// Function to show result in popup overlay
function showResultPopup(text, title = "Mimir Result") {
  const resultPopup = document.getElementById("resultPopup");
  const resultPopupText = document.getElementById("resultPopupText");
  const resultHeader = document.querySelector(".result-header");
  
  if (resultPopup && resultPopupText) {
    resultHeader.textContent = title;
    resultPopupText.textContent = text;
    resultPopup.style.display = "flex";
    
    // Focus the popup for better accessibility
    resultPopup.focus();
    
    // Re-attach close button event listener to ensure it works
    const resultCloseBtn = document.getElementById("resultCloseBtn");
    if (resultCloseBtn) {
      // Remove any existing listeners first
      resultCloseBtn.replaceWith(resultCloseBtn.cloneNode(true));
      const newCloseBtn = document.getElementById("resultCloseBtn");
      newCloseBtn.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        hideResultPopup();
      });
    }
  }
}

// Function to hide result popup
function hideResultPopup() {
  const resultPopup = document.getElementById("resultPopup");
  if (resultPopup) {
    resultPopup.style.display = "none";
  }
}

// Function to detect if server is in admin mode
async function detectAdminMode() {
  try {
    // Make a simple request to a gated tool to see if server bypasses restrictions
    const response = await fetch("https://mimir-server-daemosthene-mimir-extension.vercel.app/api/mimir", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        action: "Turn Professional",
        text: "admin mode detection test"
      })
    });

    if (response.ok) {
      const data = await response.json();
      // If we get a successful response instead of a 403 error, admin mode is likely enabled
      // Check the server logs to see if admin mode messages appear
      console.log("🔥 Admin mode detection: Server response received, checking logs...");
      
      // Set admin mode flag (you can verify this by checking server logs for admin mode messages)
      chrome.storage.local.set({ isAdminMode: true });
      console.log("🔥 CLIENT ADMIN MODE: Enabled based on server response");
    }
  } catch (error) {
    console.log("🔥 Admin mode detection failed or not enabled:", error.message);
    chrome.storage.local.set({ isAdminMode: false });
  }
}

// Function to apply the text animation effect to buttons
function applyTextEffectToButton(button) {
  // Skip if button already has the effect applied
  if (button.querySelector('.span-mother')) {
    return;
  }
  
  // Skip dropdown toggle buttons (the ones with just an arrow)
  if (button.classList.contains('toggle-description')) {
    return;
  }
  
  // Skip Enter Prompt, Edit Text, Edit Response, and Settings buttons - completely exclude them from animation
  if (button.id === 'enterPromptBtn' || 
      button.id === 'editTextBtn' || 
      button.id === 'editResponseBtn' ||
      button.id === 'bubbleModeBtn' ||
      button.id === 'openSettings' ||
      button.id === 'generatePromptBtn' ||
      button.id === 'cancelPromptBtn' ||
      button.id === 'backToTools') {
    return;
  }
  
  // Get the current button text and preserve original text for restoring if needed
  const buttonText = button.textContent.trim();
  button.dataset.originalText = buttonText;
  
  // Save original styles to apply to the spans
  const computedStyle = window.getComputedStyle(button);
  const fontFamily = computedStyle.fontFamily;
  const fontSize = computedStyle.fontSize;
  const fontWeight = computedStyle.fontWeight;
  const color = computedStyle.color;
  
  // Create the span structure for animation
  const spanMother = document.createElement('span');
  spanMother.className = 'span-mother';
  spanMother.style.fontFamily = fontFamily;
  spanMother.style.fontSize = fontSize;
  spanMother.style.fontWeight = fontWeight;
  spanMother.style.color = color;
  
  const spanMother2 = document.createElement('span');
  spanMother2.className = 'span-mother2';
  spanMother2.style.fontFamily = fontFamily;
  spanMother2.style.fontSize = fontSize;
  spanMother2.style.fontWeight = fontWeight;
  spanMother2.style.color = color;
  
  // Special handling for Enter Prompt and Edit Text buttons
  const isSpecialButton = button.id === 'enterPromptBtn' || button.id === 'editTextBtn';
  
  // Split text into individual characters and create spans
  // Using Array.from to properly handle spaces and special characters
  Array.from(buttonText).forEach(char => {
    const span1 = document.createElement('span');
    // Use non-breaking space for actual spaces to preserve them
    span1.textContent = char === ' ' ? '\u00A0' : char;
    span1.style.fontFamily = fontFamily;
    span1.style.fontSize = fontSize;
    span1.style.fontWeight = fontWeight;
    span1.style.color = color;
    // For special buttons, ensure no transform is applied to individual spans
    if (isSpecialButton) {
      span1.style.transform = 'none';
    }
    spanMother.appendChild(span1);
    
    const span2 = document.createElement('span');
    span2.textContent = char === ' ' ? '\u00A0' : char;
    span2.style.fontFamily = fontFamily;
    span2.style.fontSize = fontSize;
    span2.style.fontWeight = fontWeight;
    span2.style.color = color;
    // For special buttons, ensure no transform is applied to individual spans
    if (isSpecialButton) {
      span2.style.transform = 'none';
    }
    spanMother2.appendChild(span2);
  });
  
  // Clear the button's original content and add the new spans
  button.textContent = '';
  button.appendChild(spanMother);
  button.appendChild(spanMother2);
}

// Function to apply text effect to all buttons in the document
function applyTextEffectToAllButtons() {
  // Get all buttons
  const buttons = document.querySelectorAll('button');
  
  // Apply the effect to each button
  buttons.forEach((button) => {
    applyTextEffectToButton(button);
  });
}

// Function to show bubble mode
function showBubbleMode() {
  // Inject the bubble into the active tab instead of showing it in the popup
  chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
    if (tabs && tabs[0]) {
      chrome.scripting.executeScript({
        target: { tabId: tabs[0].id },
        func: createDetachedBubble
      });
      
      // Close the popup after injecting the bubble
      window.close();
    } else {
      console.error("No active tab found for bubble mode injection");
    }
  });
}

// Function to be injected into the webpage to create the detached bubble
function createDetachedBubble() {
  // Check if bubble already exists to avoid duplicates
  if (document.getElementById('mimir-detached-bubble')) {
    return;
  }
  
  // Get current theme from chrome storage
  chrome.storage.local.get("theme", ({ theme }) => {
    const currentTheme = theme || "default";
    
    // Define theme colors (same as main popup)
    const themeColors = {
      default: "#4287f5",
      red: "#A4262C",
      orange: "#CA5010",
      darkblue: "#40587C",
      green: "#407855",
      purple: "#8764B8",
      teal: "#038387",
      yellow: "#CEA230",
      white: "#ffffff",
      black: "#000000"
    };
    
    const accentColor = themeColors[currentTheme] || themeColors.default;
    
    // Helper function to position buttons in a 6x3 grid with centered single button in third row
    function getButtonPosition(index) {
      const containerWidth = 264; // Content area (300 - 36px padding)
      const buttonSize = 40;
      const cols = 6;
      const rows = 3;
      const buttonSpacing = 6; // Space between buttons
      
      // Calculate total grid width
      const totalGridWidth = (cols * buttonSize) + ((cols - 1) * buttonSpacing);
      
      // Calculate equal left and right margins
      const sideMargin = (containerWidth - totalGridWidth) / 2;
      
      // Calculate total grid height
      const totalGridHeight = (rows * buttonSize) + ((rows - 1) * 12);
      
      // Center the grid vertically within the content area
      const startY = (135 - totalGridHeight) / 2;
      
      // Special handling for the 13th button (AI Detector) - center it in the third row
      if (index === 12) {
        const centeredX = (containerWidth - buttonSize) / 2; // Center horizontally
        const y = startY + (2 * (buttonSize + 12)); // Third row
        return `left: ${centeredX}px; top: ${y}px;`;
      }
      
      const col = index % cols; // 6 columns (0-5)
      const row = Math.floor(index / cols); // 3 rows (0-2)
      
      const x = sideMargin + (col * (buttonSize + buttonSpacing));
      const y = startY + (row * (buttonSize + 12));
      
      return `left: ${x}px; top: ${y}px;`;
    }
    
    // Define the tools array for the bubble
    const bubbleTools = [
      { name: "Summarize", icon: "📄", description: "Get a context-aware summary of the selected text." },
      { name: "Explain Like I'm 5", icon: "🧒", description: "Simplify the selected text so a 5-year-old could understand it." },
      { name: "Translate Text", icon: "🌐", description: "Translate selected or full-page text from any language into English." },
      { name: "Definition", icon: "📖", description: "Define a selected word or phrase and optionally simplify it." },
      { name: "Turn Professional", icon: "💼", description: "Polish informal writing into professional, work-ready prose." },
      { name: "Socratic Review", icon: "🤔", description: "Ask critical questions to clarify and challenge your thinking." },
      { name: "Daily Brief", icon: "📅", description: "Summarize yesterday's notes, list tasks, and suggest what to work on." },
      { name: "Citation Finder", icon: "📚", description: "Suggest sources or references related to the selected content." },
      { name: "Flashcard Generator", icon: "🎴", description: "Turn notes or articles into tab-separated, Anki-compatible flashcards." },
      { name: "Upload Image", icon: "📷", description: "Upload an image to extract text and find answers." },
      { name: "Enter Prompt", icon: "📝", description: "Enter a custom prompt for AI processing." },
      { name: "Blink", icon: "⚡", description: "Get quick answers to your questions." },
      { name: "AI Detector", icon: "🤖", description: "Detect if text was generated by AI or written by humans." }
    ];
    
    // Create the bubble container
    const bubbleContainer = document.createElement('div');
    bubbleContainer.id = 'mimir-detached-bubble';
    
    // Generate grid buttons HTML with theme color and special handling for black theme
    const buttonsHTML = bubbleTools.map((tool, index) => `
      <div class="bubble-tool-btn" data-tool="${tool.name}" style="
        position: absolute;
        width: 40px;
        height: 40px;
        background-color: ${accentColor};
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        font-size: 18px;
        user-select: none;
        ${getButtonPosition(index)}
        ${tool.name === "Upload Image" ? "line-height: 1;" : ""}
        ${accentColor === "#000000" ? "border: 1px solid #ffffff; color: #ffffff;" : ""}
        ${accentColor === "#ffffff" ? "color: #000000;" : ""}
      " title="${tool.name}: ${tool.description}">
        ${tool.icon}
      </div>
    `).join('');
    
    bubbleContainer.innerHTML = `
      <div style="
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 300px;
        min-height: 210px;
        max-height: 310px;
        background-color: #2a2a2a;
        border: 2px solid ${accentColor};
        border-radius: 15px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        padding: 18px;
        box-sizing: border-box;
        z-index: 999999;
        font-family: Arial, sans-serif;
        cursor: grab;
        user-select: none;
        display: flex;
        flex-direction: column;
      " id="mimir-bubble-content">
        <button style="
          position: absolute;
          top: 10px;
          right: 15px;
          background: none;
          border: none;
          font-size: 20px;
          color: #999;
          cursor: pointer;
          font-family: Arial, sans-serif;
          transition: color 0.2s ease;
          z-index: 10;
        " id="mimir-close-bubble">&times;</button>
        
        <div style="
          font-size: 18px;
          font-weight: bold;
          color: ${accentColor === "#ffffff" ? "#ffffff" : accentColor};
          margin-bottom: 15px;
          font-family: Arial, sans-serif;
          text-align: center;
          flex-shrink: 0;
        ">Bubble Mode</div>
        
        <div style="
          position: relative;
          flex: 1;
          min-height: 135px;
          display: flex;
          justify-content: center;
          align-items: center;
        ">
          ${buttonsHTML}
        </div>
        
        <div id="bubble-result" style="
          margin-top: 10px;
          padding: 8px 20px 8px 8px;
          font-size: 14px;
          color: #fff;
          font-family: Arial, sans-serif;
          background: rgba(42, 42, 42, 0.8);
          border: 1px solid ${accentColor.replace('#', 'rgba(').replace(/^rgba\(/, '').replace(')', ', 0.3)')};
          border-radius: 5px;
          display: none;
          max-height: 80px;
          overflow-y: auto;
          flex-shrink: 0;
          word-wrap: break-word;
          line-height: 1.3;
          position: relative;
          backdrop-filter: blur(5px);
          scrollbar-width: thin;
          scrollbar-color: ${accentColor.replace('#', 'rgba(').replace(/^rgba\(/, '').replace(')', ', 0.6)')} rgba(42, 42, 42, 0.3);
        ">
          <style>
            #bubble-result::-webkit-scrollbar {
              width: 8px;
            }
            #bubble-result::-webkit-scrollbar-track {
              background: rgba(42, 42, 42, 0.3);
              border-radius: 4px;
            }
            #bubble-result::-webkit-scrollbar-thumb {
              background: ${accentColor.replace('#', 'rgba(').replace(/^rgba\(/, '').replace(')', ', 0.6)')};
              border-radius: 4px;
            }
            #bubble-result::-webkit-scrollbar-thumb:hover {
              background: ${accentColor.replace('#', 'rgba(').replace(/^rgba\(/, '').replace(')', ', 0.8)')};
            }
          </style>
          <button style="
            position: absolute;
            top: 2px;
            right: 4px;
            background: none;
            border: none;
            font-size: 16px;
            color: #ccc;
            cursor: pointer;
            font-family: Arial, sans-serif;
            padding: 0;
            line-height: 1;
          " id="bubble-result-close">&times;</button>
        </div>
      </div>
    `;
    
    // Add to page
    document.body.appendChild(bubbleContainer);
    
    // Get references to elements
    const bubbleContent = document.getElementById('mimir-bubble-content');
    const closeBtn = document.getElementById('mimir-close-bubble');
    const resultDiv = document.getElementById('bubble-result');
    const resultCloseBtn = document.getElementById('bubble-result-close');
    
    // Close button functionality
    closeBtn.addEventListener('click', () => {
      bubbleContainer.remove();
    });
    
    // Result close button functionality
    resultCloseBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      resultDiv.style.display = 'none';
    });
    
    // Close button hover effects
    closeBtn.addEventListener('mouseenter', () => {
      closeBtn.style.color = '#fff';
    });
    closeBtn.addEventListener('mouseleave', () => {
      closeBtn.style.color = '#999';
    });
    
    resultCloseBtn.addEventListener('mouseenter', () => {
      resultCloseBtn.style.color = '#fff';
    });
    resultCloseBtn.addEventListener('mouseleave', () => {
      resultCloseBtn.style.color = '#ccc';
    });
    
    // Function to update bubble theme
    function updateBubbleTheme(newTheme) {
      const newAccentColor = themeColors[newTheme] || themeColors.default;
      const bubbleContent = document.getElementById('mimir-bubble-content');
      const bubbleTitle = bubbleContent.querySelector('div[style*="color"]');
      const bubbleResult = document.getElementById('bubble-result');
      const toolButtons = bubbleContainer.querySelectorAll('.bubble-tool-btn');
      
      // Update bubble border
      bubbleContent.style.borderColor = newAccentColor;
      
      // Update title color - special handling for white theme
      if (bubbleTitle) {
        if (newAccentColor === "#ffffff") {
          bubbleTitle.style.color = "#ffffff"; // White text for white theme
        } else {
          bubbleTitle.style.color = newAccentColor;
        }
      }
      
      // Update result border
      if (bubbleResult) {
        bubbleResult.style.borderColor = newAccentColor.replace('#', 'rgba(').replace(/^rgba\(/, '').replace(')', ', 0.3)');
      }
      
      // Update tool buttons with special handling for black theme
      toolButtons.forEach(button => {
        button.style.backgroundColor = newAccentColor;
        
        // Add white border for black theme to make buttons visible
        if (newAccentColor === "#000000") {
          button.style.border = "1px solid #ffffff";
          button.style.color = "#ffffff";
        } else if (newAccentColor === "#ffffff") {
          button.style.border = "none";
          button.style.color = "#000000";
        } else {
          button.style.border = "none";
          button.style.color = "#ffffff";
        }
      });
    }
    
    // Listen for theme changes
    chrome.runtime.onMessage.addListener((message) => {
      if (message.type === "themeChanged" && message.theme) {
        updateBubbleTheme(message.theme);
      }
    });
    
    // Add button functionality
    const toolButtons = bubbleContainer.querySelectorAll('.bubble-tool-btn');
    toolButtons.forEach(button => {
      // Button hover effects with dynamic color and theme-specific borders
      button.addEventListener('mouseenter', () => {
        button.style.transform = 'scale(1.1)';
        // Use the current theme's accent color with transparency for hover effect
        const currentAccentColor = getComputedStyle(document.documentElement).getPropertyValue('--accent-color').trim() || accentColor;
        const hoverColor = currentAccentColor + 'dd';
        button.style.backgroundColor = hoverColor;
        
        // Maintain border for black theme on hover
        if (currentAccentColor === "#000000") {
          button.style.border = "1px solid #ffffff";
        }
      });
      
      button.addEventListener('mouseleave', () => {
        button.style.transform = 'scale(1)';
        // Restore the current theme's accent color
        const currentAccentColor = getComputedStyle(document.documentElement).getPropertyValue('--accent-color').trim() || accentColor;
        button.style.backgroundColor = currentAccentColor;
        
        // Restore border for black theme
        if (currentAccentColor === "#000000") {
          button.style.border = "1px solid #ffffff";
        }
      });
      
      // Button click functionality  
      button.addEventListener('click', async (e) => {
        e.stopPropagation();
        const toolName = button.dataset.tool;
        
        // Show result area with close button
        resultDiv.style.display = 'block';
        resultDiv.innerHTML = `
          <button style="
            position: absolute;
            top: 2px;
            right: 4px;
            background: none;
            border: none;
            font-size: 16px;
            color: #ccc;
            cursor: pointer;
            font-family: Arial, sans-serif;
            padding: 0;
            line-height: 1;
          " id="bubble-result-close">&times;</button>
          Processing ${toolName}...
        `;
        
        // Re-attach the close button event listener
        const newResultCloseBtn = document.getElementById('bubble-result-close');
        if (newResultCloseBtn) {
          newResultCloseBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            resultDiv.style.display = 'none';
          });
          
          newResultCloseBtn.addEventListener('mouseenter', () => {
            newResultCloseBtn.style.color = '#fff';
          });
          newResultCloseBtn.addEventListener('mouseleave', () => {
            newResultCloseBtn.style.color = '#ccc';
          });
        }
        
        try {
          if (toolName === "Upload Image") {
            await handleImageUpload(resultDiv);
          } else if (toolName === "Enter Prompt") {
            handleEnterPrompt(resultDiv);
          } else if (toolName === "Blink") {
            handleBlinkPrompt(resultDiv);
          } else {
            await handleTextTool(toolName, resultDiv);
          }
        } catch (error) {
          resultDiv.innerHTML = `
            <button style="
              position: absolute;
              top: 2px;
              right: 4px;
              background: none;
              border: none;
              font-size: 16px;
              color: #ccc;
              cursor: pointer;
              font-family: Arial, sans-serif;
              padding: 0;
              line-height: 1;
            " id="bubble-result-close">&times;</button>
            Error: ${error.message}
          `;
        }
      });
    });
    
    // Make bubble draggable
    let isDragging = false;
    let startX, startY, initialX, initialY;
    
    bubbleContent.addEventListener('mousedown', function(e) {
      if (e.target === closeBtn || e.target === resultCloseBtn) return;
      if (e.target.classList.contains('bubble-tool-btn')) return;
      
      isDragging = true;
      startX = e.clientX;
      startY = e.clientY;
      
      // Get current position, handling both positioned and non-positioned elements
      const rect = bubbleContent.getBoundingClientRect();
      initialX = rect.left;
      initialY = rect.top;
      
      // Ensure the bubble has fixed positioning and dimensions
      bubbleContent.style.position = 'fixed';
      bubbleContent.style.left = initialX + 'px';
      bubbleContent.style.top = initialY + 'px';
      bubbleContent.style.width = '300px'; // Lock width
      bubbleContent.style.height = '210px'; // Lock height to prevent expansion
      bubbleContent.style.minHeight = '210px'; // Maintain minimum height
      bubbleContent.style.maxHeight = '310px'; // Maintain maximum height
      bubbleContent.style.cursor = 'grabbing';
    });
    
    document.addEventListener('mousemove', function(e) {
      if (!isDragging) return;
      
      const deltaX = e.clientX - startX;
      const deltaY = e.clientY - startY;
      
      // Update position with bounds checking
      let newLeft = initialX + deltaX;
      let newTop = initialY + deltaY;
      
      // Constrain within the viewport
      const minLeft = 10;
      const minTop = 10;
      const maxLeft = window.innerWidth - 300 - 10; // Use fixed width for calculation
      const maxTop = window.innerHeight - bubbleContent.offsetHeight - 10;
      
      if (newLeft < minLeft) newLeft = minLeft;
      if (newTop < minTop) newTop = minTop;
      if (newLeft > maxLeft) newLeft = maxLeft;
      if (newTop > maxTop) newTop = maxTop;
      
      bubbleContent.style.left = newLeft + 'px';
      bubbleContent.style.top = newTop + 'px';
    });
    
    document.addEventListener('mouseup', function() {
      isDragging = false;
      bubbleContent.style.cursor = 'grab';
    });
    
    // Helper functions embedded in the injected code
    function buildRequestBody(toolName, text) {
      const base = { action: toolName, text };
      
      switch (toolName) {
        case "Summarize":
          return { ...base, mode: "concise", includeKeywords: true };
        case "Explain Like I'm 5":
          return { ...base, simplifyLevel: 5 };
        case "Citation Finder":
          return { ...base, includeLinks: true, format: "APA" };
        case "Definition":
          return { ...base, includeExamples: true, simplify: true };
        case "Daily Brief":
          return { ...base, context: "yesterday", includeTasks: true };
        case "Socratic Review":
          return { ...base, questionStyle: "dialectic", depth: "high" };
        case "Flashcard Generator":
          return { ...base, format: "anki", maxCards: 10 };
        case "Turn Professional":
          return { ...base, tone: "professional", polish: true };
        case "Translate Text":
          return { ...base, targetLanguage: "en", preserveFormat: true };
        case "AI Detector":
          return { ...base, detectAI: true };
        default:
          return base;
      }
    }
    
    function isMultipleChoiceQuestion(text) {
      if (!text.includes('A.') && !text.includes('1.') && !text.includes('option') &&
          !text.toLowerCase().includes('true') && !text.toLowerCase().includes('false')) {
        return false;
      }
      
      const mcqPattern = /(?:\n|\r|\r\n|^)\s*[A-D][\.\)].*(?:\n|\r|\r\n)\s*[A-D][\.\)].*(?:\n|\r|\r\n)\s*[A-D][\.\)].*/i;
      const numericalPattern = /(?:\n|\r|\r\n|^)\s*[1-4][\.\)].*(?:\n|\r|\r\n)\s*[1-4][\.\)].*(?:\n|\r|\r\n)\s*[1-4][\.\)].*/i;
      const trueFalsePattern = /(?:\n|\r|\r\n|^)(?:.*)(?:true\s+or\s+false|true\/false)(?:.*?)(?:\?|\.)/i;
      
      return mcqPattern.test(text) || numericalPattern.test(text) || trueFalsePattern.test(text);
    }

    async function handleTextTool(toolName, resultDiv) {
      let selectedText = window.getSelection().toString().trim();
      
      const allowFullPageFallback = !["Definition"].includes(toolName);
      
      if (!selectedText && allowFullPageFallback) {
        selectedText = document.body.innerText.trim();
        
        if (!selectedText) {
          showResult("No text found on this page.");
          return;
        }
      } else if (!selectedText) {
        showResult("Please select some text first.");
        return;
      }
      
      showResult(`Processing ${toolName}...`);
      
      try {
        chrome.runtime.sendMessage({
          type: "proxy_api_request",
          payload: {
            url: "https://mimir-server-daemosthene-mimir-extension.vercel.app/api/mimir",
            method: "POST",
            body: buildRequestBody(toolName, selectedText)
          }
        }, (response) => {
          if (chrome.runtime.lastError) {
            showResult(`Error: ${chrome.runtime.lastError.message}`);
            return;
          }
          
          if (response && response.success) {
            const dataOut = response.data;
            const result = dataOut.result || dataOut.error || 'No response received from the server.';
            showResult(result);
          } else {
            showResult(`Error: ${response ? response.error : 'No response'}`);
          }
        });
        
      } catch (error) {
        console.error("Tool error:", error);
        showResult(`Error: ${error.message}`);
      }
    }

    async function handleImageUpload(resultDiv) {
      const fileInput = document.createElement('input');
      fileInput.type = 'file';
      fileInput.accept = 'image/*';
      fileInput.style.display = 'none';
      
      fileInput.onchange = async () => {
        if (!fileInput.files || fileInput.files.length === 0) {
          return;
        }
        
        const file = fileInput.files[0];
        showResult("Uploading and processing image...");
        
        try {
          const reader = new FileReader();
          reader.onload = function(e) {
            const base64Data = e.target.result;
            
            chrome.runtime.sendMessage({
              type: "proxy_api_request",
              payload: {
                url: "https://mimir-server-daemosthene-mimir-extension.vercel.app/api/mimir",
                method: "POST",
                body: {
                  action: "Upload Image",
                  imageData: base64Data
                }
              }
            }, (response) => {
              if (chrome.runtime.lastError) {
                showResult(`Error: ${chrome.runtime.lastError.message}`);
                return;
              }
              
              if (response && response.success) {
                const dataOut = response.data;
                let outputText = '';
                if (dataOut.answers) {
                  outputText += 'ANSWERS:\n' + dataOut.answers + '\n\n';
                }
                if (dataOut.ocrText) {
                  outputText += 'EXTRACTED TEXT:\n' + dataOut.ocrText;
                }
                if (!outputText) {
                  outputText = 'No response from server.';
                }
                showResult(outputText);
              } else {
                showResult(`Error: ${response ? response.error : 'No response'}`);
              }
            });
          };
          reader.readAsDataURL(file);
          
        } catch (error) {
          showResult(`Error: ${error.message}`);
        }
      };
      
      document.body.appendChild(fileInput);
      fileInput.click();
      fileInput.remove();
    }
    
    function handleEnterPrompt(resultDiv) {
      showResult(`
        <div style="margin-bottom: 8px;">
          <textarea id="prompt-input" placeholder="Enter your prompt or question..." style="
            width: 100%;
            min-height: 60px;
            padding: 6px 8px;
            border: 1px solid rgba(66, 135, 245, 0.5);
            background: rgba(42, 42, 42, 0.9);
            color: #fff;
            border-radius: 3px;
            font-size: 12px;
            font-family: Arial, sans-serif;
            resize: vertical;
            box-sizing: border-box;
            margin-bottom: 6px;
          "></textarea>
          <div style="display: flex; gap: 4px;">
            <button id="prompt-submit" style="
              flex: 1;
              padding: 4px 8px;
              background: rgba(66, 135, 245, 0.8);
              color: #fff;
              border: none;
              border-radius: 3px;
              cursor: pointer;
              font-size: 12px;
              font-family: Arial, sans-serif;
            ">Generate</button>
            <button id="prompt-cancel" style="
              flex: 1;
              padding: 4px 8px;
              background: rgba(85, 85, 85, 0.8);
              color: #fff;
              border: none;
              border-radius: 3px;
              cursor: pointer;
              font-size: 12px;
              font-family: Arial, sans-serif;
            ">Cancel</button>
          </div>
        </div>
      `);
      
      const promptInput = document.getElementById('prompt-input');
      const promptSubmit = document.getElementById('prompt-submit');
      const promptCancel = document.getElementById('prompt-cancel');
      
      if (promptInput) promptInput.focus();
      
      if (promptSubmit) {
        promptSubmit.addEventListener('click', async () => {
          const prompt = promptInput.value.trim();
          if (!prompt) return;
          
          showResult("Processing prompt...");
          
          const isMCQ = isMultipleChoiceQuestion(prompt);
          
          chrome.runtime.sendMessage({
            type: "proxy_api_request",
            payload: {
              url: "https://mimir-server-daemosthene-mimir-extension.vercel.app/api/mimir",
              method: "POST",
              body: {
                action: isMCQ ? 'Answer MCQ' : 'Essay Response',
                text: prompt,
                detailed: true
              }
            }
          }, (response) => {
            if (chrome.runtime.lastError) {
              showResult(`Error: ${chrome.runtime.lastError.message}`);
              return;
            }
            
            if (response && response.success) {
              const dataOut = response.data;
              const result = dataOut.result || dataOut.error || 'No response received from the server.';
              showResult(result);
            } else {
              showResult(`Error: ${response ? response.error : 'No response'}`);
            }
          });
        });

      }
      
      if (promptCancel) {
        promptCancel.addEventListener('click', () => {
          resultDiv.style.display = 'none';
        });
      }
      
      if (promptInput) {
        promptInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && e.ctrlKey) {
            promptSubmit.click();
          }
        });
      }
    }
    
    function handleBlinkPrompt(resultDiv) {
      showResult(`
        <div style="margin-bottom: 8px;">
          <div style="position: relative; width: 100%;">
            <input type="text" id="blink-input" placeholder="Blink: Ask for a quick answer..." style="
              width: 100%;
              height: 26px;
              padding: 4px 30px 4px 10px;
              border: 2px solid #444;
              background-color: #333;
              color: #fff;
              font-size: 12px;
              letter-spacing: 1px;
              border-radius: 4px;
              box-sizing: border-box;
              transition: border 0.2s linear, box-shadow 0.2s linear;
            ">
            <span style="
              position: absolute;
              right: 8px;
              top: 50%;
              transform: translateY(-50%);
              cursor: pointer;
            " id="blink-submit-icon">⚡</span          </div>
        </div>
      `);
      
      const blinkInput = document.getElementById('blink-input');
      const blinkSubmitIcon = document.getElementById('blink-submit-icon');
      
      if (blinkInput) blinkInput.focus();
      
      const submitBlink = async () => {
        const question = blinkInput.value.trim();
        if (!question) return;
        
        showResult("Processing Blink question...");
        
        chrome.runtime.sendMessage({
          type: "proxy_api_request",
          payload: {
            url: "https://mimir-server-daemosthene-mimir-extension.vercel.app/api/mimir",
            method: "POST",
            body: {
              action: "Blink",
              text: question,
              maxWords: 25,
              concise: true
            }
          }
        }, (response) => {
          if (chrome.runtime.lastError) {
            showResult(`Error: ${chrome.runtime.lastError.message}`);
            return;
          }
          

          if (response && response.success) {
                       const data = response.data;
            let resultText = '';
            if (data.result) {
              resultText = data.result;
            } else if (data.error) {
              resultText = `Error: ${data.error}`;
            } else {
              resultText = 'No answer found.';
            }
            showResult(resultText);
          } else {
            showResult(`Error: ${response ? response.error : 'No response'}`);
          }
        });
      };
      
      if (blinkSubmitIcon) {
        blinkSubmitIcon.addEventListener('click', submitBlink);
      }
      
      if (blinkInput) {
        blinkInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            submitBlink();
          }
        });
        
        blinkInput.addEventListener('focus', () => {
          blinkInput.style.border = '0.5px solid #4287f5';
          blinkInput.style.boxShadow = '-3px -3px 0px #4287f5';
          blinkInput.style.outline = 'none';
        });
        
        blinkInput.addEventListener('blur', () => {
          blinkInput.style.border = '2px solid #444';
          blinkInput.style.boxShadow = 'none';
        });
      }
    }
    
    function showResult(content) {
      resultDiv.style.display = 'block';
      resultDiv.innerHTML = `
        <button style="
          position: absolute;
          top: 2px;
          right: 4px;
          background: none;
          border: none;
          font-size: 16px;
          color: #ccc;
          cursor: pointer;
          font-family: Arial, sans-serif;
          padding: 0;
          line-height: 1;
        " id="bubble-result-close">&times;</button>
        ${content}
      `;
      
      // Re-attach close button event listener
      const newCloseBtn = document.getElementById('bubble-result-close');
      if (newCloseBtn) {
        newCloseBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          resultDiv.style.display = 'none';
        });
        
        newCloseBtn.addEventListener('mouseenter', () => {
          newCloseBtn.style.color = '#fff';
        });
        newCloseBtn.addEventListener('mouseleave', () => {
          newCloseBtn.style.color = '#ccc';
        });
      }
    }
  });
  
  // ...existing helper functions...
}

// ...existing code...